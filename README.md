# proj3_bgp_router
 
Our program starts by accepting a netmask, written as a string, and returns a number of bits to be masked. It also expects an IP address written as a string, to return the binary expression of the given IP address as an integer. Next, it defines the range at which the created router is capable of receiving information from neighboring routers, using the values of the given two network's IP addresses. There is a function to check if two network's IP addresses are numerically adjacent using their netmask. Our program uses the mask length of the netmask as an integer to be assigned to each route, so that it may sort the routes in order of how optimal the routes are for any given message.
We define a router as the primary class of the router, to store the data and functionality of a BGP router. It contains 5 variables - relations, which contain the potential relationships between our router and other routers in the network, sockets for connecting out router to other routers, ports for the sockets to connect to, routing to keep track of any routes taken throughout the network from our router, and neighbors to keep track of each router's neighbors. We then initialize the router according to the specified parameters listed above to connect to the simulated network. Our router is able to connect a socket to the network and send messages to other routers in the network. One major component to our design is our approach to aggregation. When given a list of routes, the peer that is requesting certain routes to be removed, and all of the subroutes the information may travel through, we recursively check all the routes for any entries that are numerically adjacent, forward to the same next-hop router, and have the same attributes. If any routes fulfill these requirements, they are removed from the routing table, and a new route is created in their stead with an IP address that is one bit smaller to be added to the routing table. This compresses our routing table to optimize storage capacity when sending information to peers. When running our router, the sockets connecting the router to the other simulated routers throughout the network are connected, and messages are able to be sent a received to the simulation. Such messages include "update", which appends the received message onto our given routing table and aggregates any information as necessary, and checks if any of our router's neighbors are the sources of the received information. If the message received is "withdraw", then the router removes any announcement sent to it by the source of the withdraw message from the forwarding table, saves a copy of the information in case it is needed for later, and sends this copy to any of its neighbors. Finally, the router supports "data" messages, which has its forwarding table send along any data messages to their appropriate destination in the proper format specified by the assignment details. It does so by checking the IP address of the message to determine the destination of the information, the most optimal path it must take to reach its destination, and the customers or peers that it must traverse through to arrive at its destination.
